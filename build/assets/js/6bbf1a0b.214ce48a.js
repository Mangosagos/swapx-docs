"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3143],{5859:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"sdk/v3/guides/advanced/price-oracle","title":"price-oracle","description":"Introduction","source":"@site/docs/sdk/v3/guides/advanced/04-price-oracle.md","sourceDirName":"sdk/v3/guides/advanced","slug":"/sdk/v3/guides/advanced/price-oracle","permalink":"/sdk/v3/guides/advanced/price-oracle","draft":false,"unlisted":false,"editUrl":"https://github.com/hi-swapx/docs/docs/sdk/v3/guides/advanced/04-price-oracle.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_label":"\u4ef7\u683c\u9884\u8a00","sidebar_position":4},"sidebar":"sdkSidebar","previous":{"title":"\u4e3b\u52a8\u6d41\u52a8\u6027","permalink":"/sdk/v3/guides/advanced/active-liquidity"},"next":{"title":"\u8303\u56f4\u8ba2\u5355","permalink":"/sdk/v3/guides/advanced/range-orders"}}');var s=n(4848),o=n(8453);const r={sidebar_label:"\u4ef7\u683c\u9884\u8a00",sidebar_position:4},a=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding Observations",id:"understanding-observations",level:2},{value:"Fetching Observations",id:"fetching-observations",level:2},{value:"Calculating the average Price",id:"calculating-the-average-price",level:2},{value:"Calculating the average Liquidity",id:"calculating-the-average-liquidity",level:2},{value:"Why prefer observe over observations?",id:"why-prefer-observe-over-observations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(t.p,{children:["This guide will cover how to fetch price observations from a V3 pool to get onchain asset prices.\nIt is based on the ",(0,s.jsx)(t.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/oracle",children:"Price Oracle example"}),", found in the SwapX code examples ",(0,s.jsx)(t.a,{href:"https://github.com/SwapX/example",children:"repository"}),".\nTo run this example, check out the guide's ",(0,s.jsx)(t.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/oracle/README.md",children:"README"})," and follow the setup instructions."]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our ",(0,s.jsx)(t.a,{href:"01-background",children:"background"})," page!"]})}),"\n",(0,s.jsxs)(t.p,{children:["In this example we will use ",(0,s.jsx)(t.strong,{children:"ethers JS"})," to observe the development of a Pool's current tick over several blocks.\nWe will then calculate the time weighted average price - ",(0,s.jsx)(t.strong,{children:"TWAP"}),", and time weighted average liquidity - ",(0,s.jsx)(t.strong,{children:"TWAL"})," over the observed time interval."]}),"\n",(0,s.jsxs)(t.p,{children:["This guide will ",(0,s.jsx)(t.strong,{children:"cover"}),":"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Understanding observations"}),"\n",(0,s.jsx)(t.li,{children:"Fetching observations"}),"\n",(0,s.jsx)(t.li,{children:"Computing TWAP"}),"\n",(0,s.jsx)(t.li,{children:"Computing TWAL"}),"\n",(0,s.jsx)(t.li,{children:"Why prefer observe over observations"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Before diving into this guide, consider reading the theory behind using SwapX V3 as an ",(0,s.jsx)(t.a,{href:"concepts/protocol/oracle",children:"Onchain Oracle"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For this guide, the following SwapX packages are used:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.npmjs.com/package/@swapx/v3-sdk",children:(0,s.jsx)(t.code,{children:"@swapx/v3-sdk"})})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The core code of this guide can be found in ",(0,s.jsx)(t.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/oracle/src/libs/oracle.ts",children:(0,s.jsx)(t.code,{children:"oracle.ts"})})]}),"\n",(0,s.jsx)(t.h2,{id:"understanding-observations",children:"Understanding Observations"}),"\n",(0,s.jsxs)(t.p,{children:["First, we need to create a Pool contract to fetch data from the blockchain. Check out the ",(0,s.jsx)(t.a,{href:"02-pool-data",children:"Pool data guide"})," to learn how to compute the address and create an ",(0,s.jsx)(t.strong,{children:"ethers Contract"})," to interact with."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const poolContract = new ethers.Contract(\n  poolAddress,\n  ISwapXV3PoolABI.abi,\n  provider\n);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["All V3 pools store observations of the current tick and the block timestamp.\nTo minimize pool deployment costs, only one Observation is stored in the contract when the Pool is created.\nAnyone who is willing to pay the gas costs can ",(0,s.jsx)(t.a,{href:"contracts/v3/reference/core/SwapXV3Pool.md#increaseobservationcardinalitynext",children:"increase"})," the number of stored observations to up to ",(0,s.jsx)(t.code,{children:"65535"}),".\nIf the Pool cannot store an additional Observation, it overwrites the oldest one."]}),"\n",(0,s.jsx)(t.p,{children:"We create an interface to map our data to:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"interface Observation {\n  secondsAgo: number;\n  tickCumulative: bigint;\n  secondsPerLiquidityCumulativeX128: bigint;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["To fetch the ",(0,s.jsx)(t.code,{children:"Observations"})," from our pool contract, we will use the ",(0,s.jsx)(t.a,{href:"contracts/v3/reference/core/SwapXV3Pool.md#observe",children:(0,s.jsx)(t.code,{children:"observe"})})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"function observe(\n    uint32[] secondsAgos\n) external view override noDelegateCall returns (\n    int56[] tickCumulatives,\n    uint160[] secondsPerLiquidityCumulativeX128s\n)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We first check how many observations are stored in the Pool by calling the ",(0,s.jsx)(t.code,{children:"slot0"})," function."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const slot0 = await poolContract.slot0();\n\nconst observationCount = slot0.observationCardinality;\nconst maxObservationCount = slot0.observationCardinalityNext;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"observationCardinalityNext"})," is the maximum number of Observations the Pool ",(0,s.jsx)(t.strong,{children:"can store"})," at the moment.\nThe ",(0,s.jsx)(t.code,{children:"observationCardinality"})," is the actual number of Observations the Pool ",(0,s.jsx)(t.strong,{children:"has currently stored"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Observations are only stored when the ",(0,s.jsx)(t.code,{children:"swap()"})," function is called on the Pool or when a ",(0,s.jsx)(t.strong,{children:"Position is modified"}),", so it can take some time to write the Observations after the ",(0,s.jsx)(t.code,{children:"observationCardinalityNext"})," was increased.\nIf the number of Observations on the Pool is not sufficient, we need to call the ",(0,s.jsx)(t.code,{children:"increaseObservationCardinalityNext()"})," function and set it to the value we desire."]}),"\n",(0,s.jsxs)(t.p,{children:["This is a write function as the contract needs to store more data on the blockchain.\nWe will need a ",(0,s.jsx)(t.strong,{children:"wallet"})," or ",(0,s.jsx)(t.strong,{children:"signer"})," to pay the corresponding gas fee."]}),"\n",(0,s.jsx)(t.p,{children:"In this example, we want to fetch 10 observations."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import { ethers } from "ethers";\n\nlet provider = new ethers.providers.WebSocketProvider("rpcUrl...");\nlet wallet = new ethers.Wallet("private_key", provider);\n\nconst poolContract = new ethers.Contract(\n  poolAddress,\n  ISwapXV3PoolABI.abi,\n  wallet\n);\n\nconst txRes = await poolContract.increaseObservationCardinalityNext(10);\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The Pool will now fill the open Observation Slots.\nAs someone has to pay for the gas to write the observations, writing to the array of observations is part of the ",(0,s.jsx)(t.code,{children:"swap()"})," and the ",(0,s.jsx)(t.code,{children:"modifyPosition()"})," function of the Pool."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Saving an Observation is a write operation on the blockchain and therefore costs gas.\nThis means that the pool will only be able to save observations for blocks where write calls are executed on the Pool contract.\nIf no Observation is stored for a block, it is calculated as the time weighted arithmetic mean between the two closest Observations.\nBecause of this, we can be sure the oldest Observation is ",(0,s.jsx)(t.strong,{children:"at least"})," 10 blocks old.\nIt is very likely that the number of blocks covered is bigger than 10."]})}),"\n",(0,s.jsx)(t.h2,{id:"fetching-observations",children:"Fetching Observations"}),"\n",(0,s.jsxs)(t.p,{children:["We are now sure that at least 10 observations exist, and can safely fetch observations for the last 10 blocks.\nWe call the ",(0,s.jsx)(t.code,{children:"observe"})," function with an array of numbers, representing the timestamps of the Observations in seconds ago from now."]}),"\n",(0,s.jsxs)(t.p,{children:["In this example, we calculate averages over the last ten blocks so we fetch 2 observations with 9 times the blocktime in between.\nFetching an Observation ",(0,s.jsx)(t.code,{children:"0s"})," ago will return the ",(0,s.jsx)(t.strong,{children:"most recent Observation"})," interpolated to the current timestamp as observations are written at most once a block."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const timestamps = [\n    0, 108\n]\n\nconst [tickCumulatives, secondsPerLiquidityCumulatives] = await poolContract.observe(timestamps)\n\nconst observations: Observation[] = timestamps.map((time, i) => {\n    return {\n        secondsAgo: time\n        tickCumulative: BigInt(tickCumulatives[i])\n        secondsPerLiquidityCumulativeX128: BigInt(secondsPerLiquidityCumulatives[i])\n    }\n})\n"})}),"\n",(0,s.jsx)(t.p,{children:"We map the response from the RPC provider to match our Observations interface."}),"\n",(0,s.jsx)(t.h2,{id:"calculating-the-average-price",children:"Calculating the average Price"}),"\n",(0,s.jsx)(t.p,{children:"To calculate the time weighted average price (TWAP) in the period we fetched, we first need to understand what the values we fetched mean."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"tickCumulative"})," value is a snapshot of the ",(0,s.jsx)(t.code,{children:"tick accumulator"})," at the timestamp we fetched. The Tick Accumulator stores the sum of all current ticks at every second since the Pool was initialised. Its value is therefore increasing with every second."]}),"\n",(0,s.jsxs)(t.p,{children:["We cannot directly use the value of a single Observation for anything meaningful. Instead we need to compare the ",(0,s.jsx)(t.strong,{children:"difference"})," between two Observations and calculate the ",(0,s.jsx)(t.strong,{children:"time weighted arithmetic mean"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const diffTickCumulative =\n  observations[0].tickCumulative - observations[1].tickCumulative;\nconst secondsBetween = 108;\n\nconst averageTick = diffTickCumulative / secondsBetween;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now that we know the average active Tick over the last 10 blocks, we can calculate the price with the ",(0,s.jsx)(t.code,{children:"tickToPrice"})," function, which returns a ",(0,s.jsx)(t.a,{href:"core/reference/classes/Price",children:(0,s.jsx)(t.code,{children:"Price"})})," Object. Check out the ",(0,s.jsx)(t.a,{href:"02-pool-data",children:"Pool data"})," guide to understand how to construct a Pool Object and access its properties. We don't need the full Tick Data for this guide."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"import { tickToPrice, Pool } from '@swapx/v3-sdk'\n\nconst pool = new Pool(...)\n\nconst TWAP = tickToPrice(pool.token0, pool.token1, averageTick)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We have now calculated the ",(0,s.jsx)(t.strong,{children:"time weighted average price"})," over the last 108 seconds."]}),"\n",(0,s.jsx)(t.p,{children:"Let's continue with the average liquidity."}),"\n",(0,s.jsx)(t.h2,{id:"calculating-the-average-liquidity",children:"Calculating the average Liquidity"}),"\n",(0,s.jsxs)(t.p,{children:["To understand the term ",(0,s.jsx)(t.strong,{children:"active Liquidity"}),", check out the ",(0,s.jsx)(t.a,{href:"03-active-liquidity",children:"previous guide"}),".\nSimilar to the ",(0,s.jsx)(t.code,{children:"tick accumulator"}),", the ",(0,s.jsx)(t.code,{children:"liquidity accumulator"})," stores a sum of values for every second since the Pool was initialized and increases with every second.\nBecause of the size of the active liquidity value, it is impractical to just add up the active liquidity. Instead the ",(0,s.jsx)(t.strong,{children:"seconds per liquidity"})," are summed up."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"secondsPerLiquidityX128"})," value is calculated by shifting the seconds since the last Observation by 128 bits and dividing that value by the active liquidity. It is then added to the accumulator."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"uint32 delta = blockTimestamp - last.blockTimestamp;\n\nuint128 secondsPerLiquidityX128 = (uint160(delta) << 128) / liquidity\nuint160 secondsPerLiquidityCumulativeX128 = last.secondsPerLiquidityCumulativeX128 + secondsPerLiquidityX128\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"last"})," is the most recent Observation in this illustrative code snippet. Consider taking a look at the ",(0,s.jsx)(t.a,{href:"https://github.com/SwapX/v3-core/blob/main/contracts/libraries/Oracle.sol",children:"Solidity Oracle library"})," to see the actual implementation."]}),"\n",(0,s.jsx)(t.p,{children:"Let's invert this calculation and find the average active liquidity over our observed time period."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const diffSecondsPerLiquidityX128 =\n  observations[0].secondsPerLiquidityCumulativeX128 -\n  observations[1].secondsPerLiquidityCumulativeX128;\nconst secondsBetweenX128 = BigInt(108) << 128;\n\nconst TWAL = secondsBetweenX128 / diffSecondsPerLiquidityX128;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This ",(0,s.jsx)(t.strong,{children:"time weighted average liquidity"})," is the harmonic mean over the time period observed."]}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsxs)(t.p,{children:["The costs associated with manipulating/ changing the liquidity of a Pool are ",(0,s.jsx)(t.strong,{children:"orders of magnitude smaller"})," than with manipulating the price of the assets, as ",(0,s.jsx)(t.strong,{children:"prices"})," will be arbitraged for assets ",(0,s.jsx)(t.strong,{children:"with more than one market"}),".\nAdding massive amounts of liquidity to a Pool and withdrawing them after a block has passed more or less only costs gas fees."]}),(0,s.jsxs)(t.p,{children:["Use the ",(0,s.jsx)(t.strong,{children:"TWAP"})," with care and consider handling outliers."]})]}),"\n",(0,s.jsx)(t.h2,{id:"why-prefer-observe-over-observations",children:"Why prefer observe over observations?"}),"\n",(0,s.jsxs)(t.p,{children:["As touched on previously, the ",(0,s.jsx)(t.code,{children:"observe"})," function calculates Observations for the timestamps requested from the nearest observations stored in the Pool.\nIt is also possible to directly fetch the stored observations by calling the ",(0,s.jsx)(t.code,{children:"observations"})," function with the index of the Observation that we are interested in."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's fetch all observations stored in our Pool. We already made sure the observationCardinality is 10.\nThe solidity struct ",(0,s.jsx)(t.code,{children:"Observation"})," looks like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"struct Observation {\n    // the block timestamp of the observation\n    uint32 blockTimestamp;\n    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n    int56 tickCumulative;\n    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n    uint160 secondsPerLiquidityCumulativeX128;\n    // whether or not the observation is initialized\n    bool initialized;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["It is possible to request any Observation up to (excluding) index ",(0,s.jsx)(t.code,{children:"65535"}),", but indices equal to or greater than the ",(0,s.jsx)(t.code,{children:"observationCardinality"})," will return uninitialized Observations."]}),"\n",(0,s.jsxs)(t.p,{children:["The full code to the following code snippets can be found in ",(0,s.jsx)(t.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/oracle/src/libs/oracle.ts",children:(0,s.jsx)(t.code,{children:"oracle.ts"})})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"let requests = [];\nfor (let i = 0; i < 10; i++) {\n  requests.push(poolContract.observations(i));\n}\n\nconst results = await Promise.all(requests);\n"})}),"\n",(0,s.jsx)(t.p,{children:"We can only request one Observation at a time, so we create an Array of Promises to get an Array of Observations."}),"\n",(0,s.jsxs)(t.p,{children:["We already see one difference, to using the ",(0,s.jsx)(t.code,{children:"observe"})," function here.\nWhile ",(0,s.jsx)(t.code,{children:"observe"})," creates an array onchain in the smart contract and returns it, calling ",(0,s.jsx)(t.code,{children:"observations"})," requires us to make multiple RPC calls."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Depending on our setup and the Node we are using, either option can be faster, but making multiple RPC calls always has the danger of the blockchain state changing between our calls.\nWhile it is extremely unlikely, it is still possible that our Node updates with a new block and new Observation in between our calls.\nBecause we access indices of an array, this would give us an unexpected result that we need to handle as an edge case in our implementation."})}),"\n",(0,s.jsxs)(t.p,{children:["One way to handle this behaviour is deploying or ",(0,s.jsx)(t.a,{href:"https://github.com/mds1/multicall",children:"using"})," a Contract with a ",(0,s.jsx)(t.a,{href:"https://solidity-by-example.org/app/multi-call/",children:"multicall"})," functionality to get all observations with one request.\nYou can also find an example of a JS multicall in the ",(0,s.jsx)(t.a,{href:"02-pool-data",children:"Pool data guide"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"We map the RPC result to the Typescript interface that we created:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const utcNow = Math.floor(Date.now() / 1000);\nconst observations = results\n  .map((result) => {\n    const secondsAgo = utcNow - Number(result.blockTimeStamp);\n    return {\n      secondsAgo,\n      tickCumulative: BigInt(result.tickCumulative),\n      secondsPerLiquidityCumulativeX128: BigInt(\n        result.secondsPerLiquidityCumulativeX128\n      ),\n    };\n  })\n  .sort((a, b) => a.secondsAgo - b.secondsAgo);\n"})}),"\n",(0,s.jsx)(t.p,{children:"We now have an Array of observations in the same format that we are used to."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Because Observations are stored in a ",(0,s.jsx)(t.strong,{children:"fixed size array"})," with always the oldest Observation overwritten if a new one is stored, they are ",(0,s.jsx)(t.strong,{children:"not sorted"}),".\nWe need to sort the result by the timestamp."]})}),"\n",(0,s.jsxs)(t.p,{children:["The timestamps of the Observations we got are correspondent to blocks where ",(0,s.jsx)(t.strong,{children:"Swaps or Position changes"})," happened on the Pool.\nBecause of this, we would need to calculate Observations for specific intervals manually from the ",(0,s.jsx)(t.strong,{children:"surrounding Observations"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["In conclusion, it is much harder to work with ",(0,s.jsx)(t.code,{children:"observations"})," than with ",(0,s.jsx)(t.code,{children:"observe"}),", and we need to consider multiple edge cases.\nFor this reason, it is recommended to use the ",(0,s.jsx)(t.code,{children:"observe"})," function."]}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(t.p,{children:["Now that you are familiar with the Oracle feature of SwapX, consider checking out the ",(0,s.jsx)(t.a,{href:"/sdk/v3/guides/advanced/range-orders",children:"next guide"})," on ",(0,s.jsx)(t.strong,{children:"Range Orders"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);