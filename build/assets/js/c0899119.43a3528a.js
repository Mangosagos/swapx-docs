"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[679],{4684:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"sdk/v3/guides/liquidity/swap-and-add-liquidity","title":"swap-and-add-liquidity","description":"Introduction","source":"@site/docs/sdk/v3/guides/liquidity/06-swap-and-add-liquidity.md","sourceDirName":"sdk/v3/guides/liquidity","slug":"/sdk/v3/guides/liquidity/swap-and-add-liquidity","permalink":"/sdk/v3/guides/liquidity/swap-and-add-liquidity","draft":false,"unlisted":false,"editUrl":"https://github.com/hi-swapx/docs/docs/sdk/v3/guides/liquidity/06-swap-and-add-liquidity.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_label":"\u6389\u671f\u548c\u589e\u52a0\u6d41\u52a8\u6027","sidebar_position":6},"sidebar":"sdkSidebar","previous":{"title":"\u6536\u8d39","permalink":"/sdk/v3/guides/liquidity/collecting-fees"},"next":{"title":"\u5151\u6362","permalink":"/category/\u5151\u6362-1"}}');var i=t(4848),r=t(8453);const a={sidebar_label:"\u6389\u671f\u548c\u589e\u52a0\u6d41\u52a8\u6027",sidebar_position:6},s=void 0,d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Setup a router instance",id:"setup-a-router-instance",level:2},{value:"Configuring our ratio calculation",id:"configuring-our-ratio-calculation",level:2},{value:"Calculating our currency ratio",id:"calculating-our-currency-ratio",level:2},{value:"Constructing and executing our swap-and-add transaction",id:"constructing-and-executing-our-swap-and-add-transaction",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["This guide will cover how to execute a swap-and-add operation in a single atomic transaction. It is based on the ",(0,i.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/swap-and-add-liquidity",children:"swap-and-add example"}),", found in the SwapX code examples ",(0,i.jsx)(n.a,{href:"https://github.com/SwapX/examples",children:"repository"}),". To run this example, check out the examples's ",(0,i.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/swap-and-add-liquidity",children:"README"})," and follow the setup instructions."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our ",(0,i.jsx)(n.a,{href:"01-background",children:"background"})," page!"]})}),"\n",(0,i.jsx)(n.p,{children:"When adding liquidity to a SwapX v3 pool, you must provide two assets in a particular ratio. In many cases, your contract or the user's wallet hold a different ratio of those two assets. In order to deposit 100% of your assets, you must first swap your assets to the optimal ratio and then add liquidity."}),"\n",(0,i.jsxs)(n.p,{children:["However, the swap may shift the balance of the pool and thus change the optimal ratio. To avoid that, we can execute this swap-and-add liquidity operation in an atomic fashion, using a router. The inputs to our guide are the ",(0,i.jsx)(n.strong,{children:"two tokens"})," that we are pooling for, the ",(0,i.jsx)(n.strong,{children:"amount"})," of each token we are pooling for, the ",(0,i.jsx)(n.strong,{children:"amount"})," of each token to swap-and-add, and the Pool ",(0,i.jsx)(n.strong,{children:"fee"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The guide will ",(0,i.jsx)(n.strong,{children:"cover"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Setup a router instance"}),"\n",(0,i.jsx)(n.li,{children:"Configuring our ratio calculation"}),"\n",(0,i.jsx)(n.li,{children:"Calculating our currency ratio"}),"\n",(0,i.jsx)(n.li,{children:"Constructing and executing our swap-and-add transaction"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"At the end of the guide, given the inputs above, we should be able swap-and-add liquidity using 100% of the input assets with the press of a button and see the change reflected in our position and the balance of our tokens."}),"\n",(0,i.jsx)(n.p,{children:"For this guide, the following SwapX packages are used:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/v3-sdk",children:(0,i.jsx)(n.code,{children:"@swapx/v3-sdk"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/sdk-core",children:(0,i.jsx)(n.code,{children:"@swapx/sdk-core"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/smart-order-router",children:(0,i.jsx)(n.code,{children:"@swapx/smart-order-router"})})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The core code of this guide can be found in ",(0,i.jsx)(n.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/swap-and-add-liquidity/src/libs/liquidity.ts#L48",children:(0,i.jsx)(n.code,{children:"swapAndAddLiquidity()"})}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["This guide assumes you are familiar with our ",(0,i.jsx)(n.a,{href:"01-minting-position",children:"Minting a Position"})," guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted."]}),(0,i.jsxs)(n.p,{children:["Also note that we do not need to give approval to the ",(0,i.jsx)(n.code,{children:"NonfungiblePositionManager"})," to transfer our tokens as we will have already done that when minting our position."]})]}),"\n",(0,i.jsx)(n.h2,{id:"setup-a-router-instance",children:"Setup a router instance"}),"\n",(0,i.jsxs)(n.p,{children:["The first step is to approve the ",(0,i.jsx)(n.code,{children:"SwapRouter"})," smart contract to spend our tokens for us in order for us to add liquidity to our position:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const tokenInApproval = await getTokenTransferApproval(\n  token0,\n  V3_SWAP_ROUTER_ADDRESS\n);\n\nconst tokenOutApproval = await getTokenTransferApproval(\n  token1,\n  V3_SWAP_ROUTER_ADDRESS\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We described the ",(0,i.jsx)(n.code,{children:"getTokenTransferApproval"})," function ",(0,i.jsx)(n.a,{href:"/sdk/v3/guides/liquidity/minting-position#giving-approval-to-transfer-our-tokens",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Then we can setup our router, the ",(0,i.jsx)(n.a,{href:"https://github.com/SwapX/smart-order-router/blob/97c1bb7cb64b22ebf3509acda8de60c0445cf250/src/routers/alpha-router/alpha-router.ts#L333",children:(0,i.jsx)(n.code,{children:"AlphaRouter"})}),", which is part of the ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/smart-order-router",children:"smart-order-router package"}),". The router requires a ",(0,i.jsx)(n.code,{children:"chainId"})," and a ",(0,i.jsx)(n.code,{children:"provider"})," to be initialized. Note that routing is not supported for local forks, so we will use a mainnet provider even when swapping on a local fork:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { ethers } from "ethers";\nimport { AlphaRouter } from "@swapx/smart-order-router";\n\nconst provider = new ethers.providers.JsonRpcProvider(rpcUrl);\n\nconst router = new AlphaRouter({ chainId: 1, provider });\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For a more detailed example, check out our ",(0,i.jsx)(n.a,{href:"trading/03-routing",children:"routing guide"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"configuring-our-ratio-calculation",children:"Configuring our ratio calculation"}),"\n",(0,i.jsxs)(n.p,{children:["Having created the router, we now need to construct the parameters required to make a call to its ",(0,i.jsx)(n.code,{children:"routeToRatio"})," function, which will ensure the ratio of currency used matches the pool's required ratio to add our total liquidity. This will require the following parameters:"]}),"\n",(0,i.jsxs)(n.p,{children:["The first two parameters are the currency amounts we use as input to the ",(0,i.jsx)(n.code,{children:"routeToRatio"})," algorithm:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { CurrencyAmount } from "@swapx/sdk-core";\n\nconst token0CurrencyAmount = CurrencyAmount.fromRawAmount(\n  token0,\n  fromReadableAmount(token0AmountToAdd, token0.decimals)\n);\n\nconst token1CurrencyAmount = CurrencyAmount.fromRawAmount(\n  token1,\n  fromReadableAmount(token1AmountToAdd, token1.decimals)\n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Next, we will create a placeholder position with a liquidity of ",(0,i.jsx)(n.code,{children:"1"})," since liquidity is still unknown and will be set inside the call to ",(0,i.jsx)(n.code,{children:"routeToRatio"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Pool, Position, nearestUsableTick } from '@swapx/v3-sdk'\n\nconst placeholderPosition = new Position{\n    pool,\n    liquidity: 1,\n    tickLower:\n      nearestUsableTick(pool.tickCurrent, pool.tickSpacing) -\n      pool.tickSpacing * 2,\n    tickUpper:\n      nearestUsableTick(pool.tickCurrent, pool.tickSpacing) +\n      poolInfo.tickSpacing * 2\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We then need to create an instance of ",(0,i.jsx)(n.code,{children:"SwapAndAddConfig"})," which will set additional configuration parameters for the ",(0,i.jsx)(n.code,{children:"routeToRatio"})," algorithm:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ratioErrorTolerance"})," determines the margin of error the resulting ratio can have from the optimal ratio."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"maxIterations"})," determines the maximum times the algorithm will iterate to find a ratio within error tolerance. If max iterations is exceeded, an error is returned. The benefit of running the algorithm more times is that we have more chances to find a route, but more iterations will longer to execute. We've used a default of 6 in our example."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { Fraction } from "@swapx/sdk-core";\nimport { SwapAndAddConfig } from "@swapx/smart-order-router";\n\nconst swapAndAddConfig: SwapAndAddConfig = {\n  ratioErrorTolerance: new Fraction(1, 100),\n  maxIterations: 6,\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, we will create an instance of ",(0,i.jsx)(n.code,{children:"SwapAndAddOptions"})," to configure which position we are adding liquidity to and our defined swapping parameters in two different objects:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"swapConfig"})})," configures the ",(0,i.jsx)(n.code,{children:"recipient"})," of leftover dust from swap, ",(0,i.jsx)(n.code,{children:"slippageTolerance"})," and a ",(0,i.jsx)(n.code,{children:"deadline"})," for the swap."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"addLiquidityOptions"})})," must contain a ",(0,i.jsx)(n.code,{children:"tokenId"})," to add to an existing position"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { SwapAndAddOptions } from "@swapx/smart-order-router";\n\nconst swapAndAddOptions: SwapAndAddOptions = {\n  swapOptions: {\n    type: SwapType.SWAP_ROUTER_02,\n    recipient: address,\n    slippageTolerance: new Percent(50, 10_000),\n    deadline: Math.floor(Date.now() / 1000) + 60 * 20,\n  },\n  addLiquidityOptions: {\n    tokenId: positionId,\n  },\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"calculating-our-currency-ratio",children:"Calculating our currency ratio"}),"\n",(0,i.jsxs)(n.p,{children:["Having constructed all the parameters we need to call ",(0,i.jsx)(n.code,{children:"routeToRatio"}),", we can now make the call to the function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { SwapToRatioResponse } from "@swapx/smart-order-router";\n\nconst routeToRatioResponse: SwapToRatioResponse = await router.routeToRatio(\n  token0CurrencyAmount,\n  token1CurrencyAmount,\n  currentPosition,\n  swapAndAddConfig,\n  swapAndAddOptions\n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The return type of the function call is ",(0,i.jsx)(n.a,{href:"https://github.com/SwapX/smart-order-router/blob/97c1bb7cb64b22ebf3509acda8de60c0445cf250/src/routers/router.ts#L121",children:"SwapToRatioResponse"}),". If a route was found successfully, this object will have two fields: the status (success) and the ",(0,i.jsx)(n.code,{children:"SwapToRatioRoute"})," object. We check to make sure that both of those conditions hold true before we construct and submit the transaction:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { SwapToRatioStatus } from "@swapx/smart-order-router";\n\nif (\n  !routeToRatioResponse ||\n  routeToRatioResponse.status !== SwapToRatioStatus.SUCCESS\n) {\n  // Handle Failed Transaction\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In case a route was not found, we return from the function a ",(0,i.jsx)(n.code,{children:"Failed"})," state for the transaction."]}),"\n",(0,i.jsx)(n.h2,{id:"constructing-and-executing-our-swap-and-add-transaction",children:"Constructing and executing our swap-and-add transaction"}),"\n",(0,i.jsxs)(n.p,{children:["After making sure that a route was successfully found, we can now construct and send the transaction. The response (",(0,i.jsx)(n.code,{children:"SwapToRatioRoute"}),") will have the properties we need to construct our transaction object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { SwapToRatioRoute } from "@swapx/smart-order-router";\n\nconst route: SwapToRatioRoute = routeToRatioResponse.result;\nconst transaction = {\n  data: route.methodParameters?.calldata,\n  to: V3_SWAP_ROUTER_ADDRESS,\n  value: route.methodParameters?.value,\n  from: address,\n};\n\nconst txRes = await wallet.sendTransaction(transaction);\n'})}),"\n",(0,i.jsx)(n.p,{children:"If the transaction was successful, our swap-and-add will be completed! We should see our input token balances decrease and our position balance should be increased accordingly."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);