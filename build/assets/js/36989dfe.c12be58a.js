"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9759],{6119:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"sdk/v3/guides/liquidity/minting-position","title":"minting-position","description":"Introduction","source":"@site/docs/sdk/v3/guides/liquidity/02-minting-position.md","sourceDirName":"sdk/v3/guides/liquidity","slug":"/sdk/v3/guides/liquidity/minting-position","permalink":"/sdk/v3/guides/liquidity/minting-position","draft":false,"unlisted":false,"editUrl":"https://github.com/hi-swapx/docs/docs/sdk/v3/guides/liquidity/02-minting-position.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"\u94f8\u9020\u4f4d\u7f6e","sidebar_position":2},"sidebar":"sdkSidebar","previous":{"title":"\u4f4d\u7f6e\u6570\u636e","permalink":"/sdk/v3/guides/liquidity/position-data"},"next":{"title":"\u83b7\u53d6\u4f4d\u7f6e","permalink":"/sdk/v3/guides/liquidity/fetching-positions"}}');var o=t(4848),s=t(8453);const r={sidebar_label:"\u94f8\u9020\u4f4d\u7f6e",sidebar_position:2},a=void 0,c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Giving approval to transfer our tokens",id:"giving-approval-to-transfer-our-tokens",level:2},{value:"Creating an instance of a <code>Pool</code>",id:"creating-an-instance-of-a-pool",level:2},{value:"Calculating our <code>Position</code> from our input tokens",id:"calculating-our-position-from-our-input-tokens",level:2},{value:"Configuring and executing our minting transaction",id:"configuring-and-executing-our-minting-transaction",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["This guide will cover how to create (or mint) a liquidity position on the SwapX V3 protocol.\nIt is based on the ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/minting-position",children:"minting a position code example"}),", found in the SwapX code examples ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/examples",children:"repository"}),".\nTo run this example, check out the examples's ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/minting-position/README.md",children:"README"})," and follow the setup instructions."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our ",(0,o.jsx)(n.a,{href:"01-background",children:"background"})," page!"]})}),"\n",(0,o.jsxs)(n.p,{children:["In the SwapX V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the ",(0,o.jsx)(n.code,{children:"NonfungiblePositionManager"})," class to help us mint a liquidity position for the ",(0,o.jsx)(n.strong,{children:"USDC - DAI"})," pair. The inputs to our guide are the ",(0,o.jsx)(n.strong,{children:"two tokens"})," that we are pooling for, the ",(0,o.jsx)(n.strong,{children:"amount"})," of each token we are pooling for and the Pool ",(0,o.jsx)(n.strong,{children:"fee"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The guide will ",(0,o.jsx)(n.strong,{children:"cover"}),":"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Giving approval to transfer our tokens"}),"\n",(0,o.jsxs)(n.li,{children:["Creating an instance of a ",(0,o.jsx)(n.code,{children:"Pool"})]}),"\n",(0,o.jsxs)(n.li,{children:["Calculating our ",(0,o.jsx)(n.code,{children:"Position"})," from our input tokens"]}),"\n",(0,o.jsx)(n.li,{children:"Configuring and executing our minting transaction"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"At the end of the guide, given the inputs above, we should be able to mint a liquidity position with the press of a button and view the position on the UI of the web application."}),"\n",(0,o.jsx)(n.p,{children:"For this guide, the following SwapX packages are used:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/v3-sdk",children:(0,o.jsx)(n.code,{children:"@swapx/v3-sdk"})})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/sdk-core",children:(0,o.jsx)(n.code,{children:"@swapx/sdk-core"})})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/smart-order-router",children:(0,o.jsx)(n.code,{children:"@swapx/smart-order-router"})})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The core code of this guide can be found in ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/minting-position/src/libs/positions.ts#L37",children:(0,o.jsx)(n.code,{children:"mintPosition()"})})]}),"\n",(0,o.jsx)(n.h2,{id:"giving-approval-to-transfer-our-tokens",children:"Giving approval to transfer our tokens"}),"\n",(0,o.jsxs)(n.p,{children:["We want to use the ",(0,o.jsx)(n.code,{children:"NonfungiblePositionManager"})," contract to create our liqudity position.\nIn situations where a smart contract is transfering tokens on our behalf, we need to give it approval to do so.\nThis is done by interacting with the Contract of the contract, considering ERC20 Tokens are smart contracts of their own."]}),"\n",(0,o.jsxs)(n.p,{children:["Considering this, the first step to create our position is to give approval to the protocol's ",(0,o.jsx)(n.code,{children:"NonfungiblePositionManager"})," to transfer our tokens:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const token0Approval = await getTokenTransferApproval(token0Address, amount0);\nconst token1Approval = await getTokenTransferApproval(token1Address, amount1);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The logic to achieve that is wrapped in the ",(0,o.jsx)(n.code,{children:"getTokenTransferApprovals"})," function. In short, since both ",(0,o.jsx)(n.strong,{children:"USDC"})," and ",(0,o.jsx)(n.strong,{children:"DAI"})," are ERC20 tokens, we setup a reference to their smart contracts and call the ",(0,o.jsx)(n.code,{children:"approve"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { ethers, BigNumber } from "ethers";\n\nasync function getTokenTransferApproval(address: string, amount: BigNumber) {\n  const provider = new ethers.providers.JsonRpcProvider(rpcUrl);\n\n  const tokenContract = new ethers.Contract(token.address, ERC20_ABI, provider);\n\n  return tokenContract.approve(\n    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,\n    amount\n  );\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We can get the Contract address for the NonfungiblePositionManager from ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/v3-periphery/blob/main/deploys.md",children:"Github"}),".\nFor Ethereum mainnet or a local fork of mainnet, we see that the contract address is ",(0,o.jsx)(n.code,{children:"0xC36442b4a4522E871399CD717aBDD847Ab11FE88"}),".\nIn our example, this is defined in the ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/minting-position/src/libs/constants.ts",children:(0,o.jsx)(n.code,{children:"constants.ts"})})," file."]}),"\n",(0,o.jsxs)(n.h2,{id:"creating-an-instance-of-a-pool",children:["Creating an instance of a ",(0,o.jsx)(n.code,{children:"Pool"})]}),"\n",(0,o.jsx)(n.p,{children:"Having approved the transfer of our tokens, we now need to get data about the pool for which we will provide liquidity, in order to instantiate a Pool class."}),"\n",(0,o.jsxs)(n.p,{children:["To start, we compute our Pool's address by using a helper function and passing in the unique identifiers of a Pool - the ",(0,o.jsx)(n.strong,{children:"two tokens"})," and the Pool ",(0,o.jsx)(n.strong,{children:"fee"}),".\nThe ",(0,o.jsx)(n.strong,{children:"fee"})," input parameter represents the swap fee that is distributed to all in range liquidity at the time of the swap."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { computePoolAddress, FeeAmount } from '@swapx/v3-sdk'\nimport { Token } from '@swapx/sdk-core'\n\nconst token0: Token = ...\nconst token1: Token = ...\nconst fee: FeeAmount = ...\nconst POOL_FACTORY_CONTRACT_ADDRESS: string = ...\n\nconst currentPoolAddress = computePoolAddress({\n  factoryAddress: POOL_FACTORY_CONTRACT_ADDRESS,\n  tokenA: token0,\n  tokenB: token1,\n  fee: poolFee,\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Again, we can get the factory contract address from ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/v3-periphery/blob/main/deploys.md",children:"Github"}),".\nFor Ethereum mainnet, or a local fork of mainnet, it is ",(0,o.jsx)(n.code,{children:"0x1F98431c8aD98523631AE4a59f267346ea31F984"}),".\nIn our example, it is defined in ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/minting-position/src/libs/constants.ts",children:(0,o.jsx)(n.code,{children:"constants.ts"})})]}),"\n",(0,o.jsxs)(n.p,{children:["Then, we get the Pool's data by creating a reference to the Pool's smart contract and accessing its methods, very similar to what we did in the ",(0,o.jsx)(n.a,{href:"swaps/01-quoting.md#referencing-the-pool-contract-and-fetching-metadata",children:"Quoting guide"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import ISwapXV3PoolABI from "@swapx/v3-core/artifacts/contracts/interfaces/ISwapXV3Pool.sol/ISwapXV3Pool.json";\n\nconst poolContract = new ethers.Contract(\n  currentPoolAddress,\n  ISwapXV3PoolABI.abi,\n  provider\n);\n\nconst [liquidity, slot0] = await Promise.all([\n  poolContract.liquidity(),\n  poolContract.slot0(),\n]);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Having collected the required data, we can now create an instance of the ",(0,o.jsx)(n.code,{children:"Pool"})," class:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { Pool } from "@swapx/v3-sdk";\n\nconst configuredPool = new Pool(\n  token0,\n  token1,\n  poolFee,\n  slot0.sqrtPriceX96.toString(),\n  liquidity.toString(),\n  slot0.tick\n);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We need a Pool instance to create our Position as various parameters of liquidity positions depend on the state of the Pool where they are created.\nAn example is the current price (named ",(0,o.jsx)(n.em,{children:"sqrtPriceX96"})," after the way it is encoded) to know the ratio of the two Tokens we need to send to the Pool."]}),"\n",(0,o.jsx)(n.p,{children:"Liquidity provided below the current Price will be provided in the first Token of the Pool, while liquidity provided above the current Price is made up by the second Token."}),"\n",(0,o.jsxs)(n.h2,{id:"calculating-our-position-from-our-input-tokens",children:["Calculating our ",(0,o.jsx)(n.code,{children:"Position"})," from our input tokens"]}),"\n",(0,o.jsxs)(n.p,{children:["Having created the instance of the ",(0,o.jsx)(n.code,{children:"Pool"})," class, we can now use that to create an instance of a ",(0,o.jsx)(n.code,{children:"Position"})," class, which represents the price range for a specific pool that LPs choose to provide in:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { Position } from '@swapx/v3-sdk'\nimport { BigIntish } from '@swapx/sdk-core'\n\n// The maximum token amounts we want to provide. BigIntish accepts number, string or JSBI\nconst amount0: BigIntish = ...\nconst amount1: BigIntish = ...\n\nconst position = Position.fromAmounts({\n  pool: configuredPool,\n  tickLower:\n    nearestUsableTick(configuredPool.tickCurrent, configuredPool.tickSpacing) -\n    configuredPool.tickSpacing * 2,\n  tickUpper:\n    nearestUsableTick(configuredPool.tick, configuredPool.tickSpacing) +\n    configuredPool.tickSpacing * 2,\n  amount0: amount0,\n  amount1: amount1,\n  useFullPrecision: true,\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We use the ",(0,o.jsx)(n.code,{children:"fromAmounts"})," static function of the ",(0,o.jsx)(n.code,{children:"Position"})," class to create an instance of it, which uses the following parameters:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.strong,{children:"tickLower"})," and ",(0,o.jsx)(n.strong,{children:"tickUpper"})," parameters specify the price range at which to provide liquidity. This example calls ",(0,o.jsx)(n.strong,{children:"nearestUsableTick"})," to get the current useable tick and adjust the lower parameter to be below it by two ",(0,o.jsx)(n.strong,{children:"tickSpacing"}),' and the upper to be above it by two tickSpacing. This guarantees that the provided liquidity is "in range", meaning it will be earning fees upon minting this position']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"amount0"})," and ",(0,o.jsx)(n.strong,{children:"amount1"})," define the maximum amount of currency the liquidity position can use. In this example, we supply these from our configuration parameters."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Given those parameters, ",(0,o.jsx)(n.code,{children:"fromAmounts"})," will attempt to calculate the maximum amount of liquidity we can supply."]}),"\n",(0,o.jsx)(n.h2,{id:"configuring-and-executing-our-minting-transaction",children:"Configuring and executing our minting transaction"}),"\n",(0,o.jsxs)(n.p,{children:["The Position instance is then passed as input to the ",(0,o.jsx)(n.code,{children:"NonfungiblePositionManager"}),"'s ",(0,o.jsx)(n.code,{children:"addCallParameters"})," function. The function also requires an ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L77",children:(0,o.jsx)(n.code,{children:"AddLiquidityOptions"})})," object as its second parameter. This is either of type ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L74",children:(0,o.jsx)(n.code,{children:"MintOptions"})})," for minting a new position or ",(0,o.jsx)(n.a,{href:"https://github.com/SwapX/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L75",children:(0,o.jsx)(n.code,{children:"IncreaseOptions"})})," for adding liquidity to an existing position. For this example, we're using a ",(0,o.jsx)(n.code,{children:"MintOptions"})," to create our position."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { MintOptions, NonfungiblePositionManager } from "@swapx/v3-sdk";\nimport { Percent } from "@swapx/sdk-core";\n\nconst mintOptions: MintOptions = {\n  recipient: address,\n  deadline: Math.floor(Date.now() / 1000) + 60 * 20,\n  slippageTolerance: new Percent(50, 10_000),\n};\n\n// get calldata for minting a position\nconst { calldata, value } = NonfungiblePositionManager.addCallParameters(\n  position,\n  mintOptions\n);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"MintOptions"})," interface requires three keys:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"recipient"})," defines the address of the Position owner, so in our case the address of our wallet."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"deadline"})," defines the latest point in time at which we want our transaction to be included in the blockchain."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"slippageTolerance"})," defines the maximum amount of ",(0,o.jsx)(n.strong,{children:"change of the ratio"})," of the Tokens we provide. The ratio can change if for example ",(0,o.jsx)(n.strong,{children:"trades"})," that change the price of the Pool are included before our transaction."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"addCallParameters"})," function returns the calldata as well as the value required to execute the transaction:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const transaction = {\n  data: calldata,\n  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,\n  value: value,\n  from: address,\n  maxFeePerGas: MAX_FEE_PER_GAS,\n  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"We use our wallet to send the transaction. As it is a write call, we need to sign the transaction with a valid private key."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const wallet = new ethers.Wallet(privateKey, provider);\n\nconst txRes = await wallet.sendTransaction(transaction);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Write calls do not return the result of the transaction. If we want to read the result we would need to use for example ",(0,o.jsx)(n.code,{children:"trace_transaction"}),".\nYou can find an example of that in the ",(0,o.jsx)(n.a,{href:"advanced/05-range-orders",children:"Range Order guide"}),".\nIn this example, we don't need the result of the transaction."]}),"\n",(0,o.jsx)(n.p,{children:"The effect of the transaction is to mint a new Position NFT. We should see a new position with liquidity in our list of positions."}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.p,{children:["Once you have minted a position, our next guide ",(0,o.jsx)(n.a,{href:"04-modifying-position",children:"Adding and Removing Liquidity"})," will demonstrate how you can add and remove liquidity from that minted position!"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);