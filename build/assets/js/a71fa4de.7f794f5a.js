"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3468],{5145:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"sdk/v3/guides/advanced/active-liquidity","title":"active-liquidity","description":"Introduction","source":"@site/docs/sdk/v3/guides/advanced/03-active-liquidity.md","sourceDirName":"sdk/v3/guides/advanced","slug":"/sdk/v3/guides/advanced/active-liquidity","permalink":"/sdk/v3/guides/advanced/active-liquidity","draft":false,"unlisted":false,"editUrl":"https://github.com/hi-swapx/docs/docs/sdk/v3/guides/advanced/03-active-liquidity.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"\u4e3b\u52a8\u6d41\u52a8\u6027","sidebar_position":3},"sidebar":"sdkSidebar","previous":{"title":"\u6c60\u6570\u636e","permalink":"/sdk/v3/guides/advanced/pool-data"},"next":{"title":"\u4ef7\u683c\u9884\u8a00","permalink":"/sdk/v3/guides/advanced/price-oracle"}}');var s=t(4848),r=t(8453);const c={sidebar_label:"\u4e3b\u52a8\u6d41\u52a8\u6027",sidebar_position:3},a=void 0,o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding Active Liquidity",id:"understanding-active-liquidity",level:2},{value:"Initialized Ticks",id:"initialized-ticks",level:3},{value:"Fetching initialized Ticks",id:"fetching-initialized-ticks",level:3},{value:"Current Tick",id:"current-tick",level:3},{value:"Tickspacing",id:"tickspacing",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:3},{value:"Calculating active liquidity",id:"calculating-active-liquidity",level:2},{value:"Drawing the Chart",id:"drawing-the-chart",level:2},{value:"Locked Liquidity",id:"locked-liquidity",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(i.p,{children:["This guide will cover how to fetch and compute the active liquidity in the specific Tick ranges of a pool. It is based on the ",(0,s.jsx)(i.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/liquidity-density",children:"Liquidity Density example"})," and can be seen used in production, albeit in a more sophisticated way, in the ",(0,s.jsx)(i.a,{href:"https://info.SwapX.org/#/pools",children:"SwapX Analytics"})," website."]}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsxs)(i.p,{children:["If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our ",(0,s.jsx)(i.a,{href:"01-background",children:"background"})," page!"]})}),"\n",(0,s.jsxs)(i.p,{children:["In this guide, we will use the V3 subgraph to fetch all ticks from ",(0,s.jsx)(i.strong,{children:"theGraph"})," and compute the active liquidity our Pool can use at each Tick. We then use ",(0,s.jsx)(i.code,{children:"recharts"})," to draw a chart that visualizes our Pool's liqudity density."]}),"\n",(0,s.jsx)(i.p,{children:"This guide will cover:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Getting the tickSpacing and currently active Tick from the Pool"}),"\n",(0,s.jsx)(i.li,{children:"Calculating active liquidity from net liquidity"}),"\n",(0,s.jsx)(i.li,{children:"Drawing a chart from the Tick data"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This guide will not cover:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Specifics of working with the recharts library. You can read more about that ",(0,s.jsx)(i.a,{href:"https://recharts.org/en-US/",children:"here"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"At the end of the guide, we should be able to visualize the liquidity of any V3 Pool."}),"\n",(0,s.jsx)(i.h2,{id:"understanding-active-liquidity",children:"Understanding Active Liquidity"}),"\n",(0,s.jsx)(i.p,{children:"To visualize the distribution of active liquidity in our Pool, we want to draw our Chart around the currently active Tick. For that we have to first understand:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"What is an initialized Tick?"}),"\n",(0,s.jsx)(i.li,{children:"What is the current Tick?"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"initialized-ticks",children:"Initialized Ticks"}),"\n",(0,s.jsxs)(i.p,{children:["When providing liquidity for a pool, the LP decides the ",(0,s.jsx)(i.strong,{children:"price range"})," in which the liquidity should be provided, and the amount of liquidity to be provided.\nThe pool understands the position as ",(0,s.jsx)(i.strong,{children:"liquidity between the lower and upper Tick"}),". The Tick Index in this context is a representation of the price between the Pool's assets."]}),"\n",(0,s.jsxs)(i.p,{children:["Looking at this ",(0,s.jsx)(i.a,{href:"https://www.desmos.com/calculator/oduetjzfp4",children:"visualization"})," of multiple positions in a V3 Pool, we can see that the liquidity available for a swap does not change inside a position, but when crossing into the next position.\nThis is what the ",(0,s.jsx)(i.strong,{children:"Initialized Ticks"})," of a Pool represent - they are a representation of the start or end of one or more positions."]}),"\n",(0,s.jsx)("img",{src:"/img/liquidityNetComparison.png",alt:"LiquidityNet1"}),"\n",(0,s.jsxs)(i.p,{children:["When entering or leaving a position, its liquidity is added or removed from the ",(0,s.jsx)(i.strong,{children:"active liquidity available"})," for a Swap.\nThe initialized Ticks store this ",(0,s.jsx)(i.strong,{children:"change in available liquidity"})," in the ",(0,s.jsx)(i.code,{children:"liquidityNet"})," field.\nThe change is always stored in relation to the currently active Tick - the current price.\nWhen the price crosses an initialized Tick, it gets updated and liqudity that was previously added when crossing the Tick would now be removed and vice versa."]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"liquidityGross"})," value represents the gross value of liquidity referencing the tick.\nThis is important for the edge case that one position ends at a Tick and a second position with exactly the same liquidity value would start at the Tick.\nIn this case ",(0,s.jsx)(i.code,{children:"liquidityNet"})," would be ",(0,s.jsx)(i.strong,{children:"0"})," but ",(0,s.jsx)(i.code,{children:"liquidityGross"})," would still have a value, which ensures that the Tick is not deleted from the Pool."]}),"\n",(0,s.jsxs)(i.p,{children:["To visualize liquidity in a graph, we will only need to consider the changes, so it's sufficient to fetch the Ticks with ",(0,s.jsx)(i.code,{children:"liquidityNet"})," not 0."]}),"\n",(0,s.jsx)(i.h3,{id:"fetching-initialized-ticks",children:"Fetching initialized Ticks"}),"\n",(0,s.jsxs)(i.p,{children:["To fetch all ticks of our Pool, we will use the ",(0,s.jsx)(i.a,{href:"api/subgraph/overview",children:"SwapX V3 graph"}),".\nTo visualize active liquidity, we need the ",(0,s.jsx)(i.strong,{children:"tickIdx"}),", the ",(0,s.jsx)(i.strong,{children:"liquidityGross"})," and the ",(0,s.jsx)(i.strong,{children:"liquidityNet"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["We define our GraphQL query and ",(0,s.jsx)(i.a,{href:"https://axios-http.com/docs/post_example",children:"send a POST request"})," to the V3 subgraph API endpoint:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'axios.post(\n  "https://api.thegraph.com/subgraphs/name/SwapX/SwapX-v3",\n  {\n    query: `{ ticks(\n              where: {poolAddress: "${poolAddress.toLowerCase()}", liquidityNet_not: "0"}\n              first: 1000,\n              skip: ${skip},\n              orderBy: tickIdx,\n              orderDirection: asc\n            ) {\n              tickIdx\n              liquidityGross\n              liquidityNet\n            }\n          }`,\n  },\n  {\n    headers: {\n      "Content-Type": "application/json",\n    },\n  }\n);\n'})}),"\n",(0,s.jsxs)(i.p,{children:["We only fetch the ticks that ",(0,s.jsx)(i.strong,{children:"have liquidity"}),", and we convert the poolAddress to ",(0,s.jsx)(i.strong,{children:"lower case"})," for the subgraph to work with. To make sure the Ticks are ordered correctly, we also define the ",(0,s.jsx)(i.strong,{children:"order direction"})," in the query."]}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsx)(i.p,{children:"GraphQL is only able to fetch 1000 records at a time. If a pool has more than 1000 initialized ticks, multiple calls are necessary to get all of them."})}),"\n",(0,s.jsxs)(i.p,{children:["The ticks we got from ",(0,s.jsx)(i.strong,{children:"theGraph"})," have this format:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"interface GraphTick {\n  tickIdx: string;\n  liquidityGross: string;\n  liquidityNet: string;\n}\n"})}),"\n",(0,s.jsx)(i.h3,{id:"current-tick",children:"Current Tick"}),"\n",(0,s.jsxs)(i.p,{children:["The current Tick of the Pool represents the ",(0,s.jsx)(i.strong,{children:"current Price"})," after the last swap.\nConsidering that the initialized Ticks only represent positions, we see that it is not necessarily one of the initialized Ticks but can be at any point in between them.\nThe active liqudity at the current Price is also stored in the smart contract - we already fetched it with the ",(0,s.jsx)(i.code,{children:"liquidity"})," function in the ",(0,s.jsx)(i.a,{href:"02-pool-data",children:"previous guide"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"tickspacing",children:"Tickspacing"}),"\n",(0,s.jsx)(i.p,{children:"Only the Ticks with indices that are divisible with 0 remainder by the tickspacing of a Pool are initializable.\nThis is a convention defined by the protocol to save gas.\nThe Tickspacing of the Pool is dependent on the Fee Tier.\nPools with lower fees are meant to be used for more stable Token Pairs and allow for more granularity in where LPs position their liquidity."}),"\n",(0,s.jsxs)(i.p,{children:["We can get the ",(0,s.jsx)(i.code,{children:"tickSpacing"})," from the ",(0,s.jsx)(i.code,{children:"TICK_SPACINGS"})," enum exposed by the ",(0,s.jsx)(i.code,{children:"v3-sdk"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"import { TICK_SPACINGS }\n\nconst tickSpacing = TICK_SPACINGS[fee]\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Alternatively, if we have already constructed a ",(0,s.jsx)(i.code,{children:"Pool"})," object, we could just call ",(0,s.jsx)(i.code,{children:"Pool.tickSpacing()"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,s.jsx)(i.p,{children:"For the purpose of visualizing the liquidity density of the Pool, it rarely makes sense to display the full Tick Range of the Pool, as the vast majority of liquidity will be focused in a narrow price range."}),"\n",(0,s.jsx)(i.p,{children:"Instead, we will display a sensible number of Ticks around the current price."}),"\n",(0,s.jsx)(i.h2,{id:"calculating-active-liquidity",children:"Calculating active liquidity"}),"\n",(0,s.jsx)(i.p,{children:"We know the spacing between Ticks and the Initialized Ticks where active liquidity changes.\nAll we have to do is start calculating from the current Tick and iterate outwards."}),"\n",(0,s.jsxs)(i.p,{children:["The code mentioned in the following snippets can be found in ",(0,s.jsx)(i.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/pool-data/src/libs/active-liquidity.ts",children:(0,s.jsx)(i.code,{children:"active-liquidity.ts"})}),"."]}),"\n",(0,s.jsx)(i.p,{children:"To draw our chart we want a data structure that looks something like this:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"interface TickProcessed {\n  tickIdx: number;\n  liquidityActive: JSBI;\n  liquidityNet: JSBI;\n  price0: string;\n  price1: string;\n  isCurrent: boolean;\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["To access the initialized Ticks directly from their Tick Index, we store them in a ",(0,s.jsx)(i.a,{href:"https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type",children:"Record"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"const tickIdxToTickDictionary: Record<string, GraphTick> = Object.fromEntries(\n  ticks.map((graphTick) => [graphTick.tickIdx, graphTick])\n);\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"ticks"})," variable in this code snippet is the result we got from the V3 Subgraph earlier."]}),"\n",(0,s.jsxs)(i.p,{children:["We want to mark the Tick closest to the current Price and we want to be able to display the prices at a Tick to the user.\nWe calculate the ",(0,s.jsx)(i.strong,{children:"initializable Tick"})," closest to the current price and create the active Tick that we start from:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'import { tickToPrice } from "@swapx/v3-sdk";\n\nconst activeTickIdx = Math.floor(pool.tickCurrent / tickSpacing) * tickSpacing;\n\nconst activeTickProcessed: TickProcessed = {\n  tickIdx: activeTickIdx,\n  liquidityActive: pool.liquidity,\n  liquidityNet: JSBI.BigInt(0),\n  price0: tickToPrice(tokenA, tokenB, activeTickIdx).toFixed(6),\n  price1: tickToPrice(tokenB, tokenA, activeTickIdx).toFixed(6),\n  isCurrent: true,\n};\n'})}),"\n",(0,s.jsxs)(i.p,{children:["Here we also calculate the price of the tokens from the tickIdx, the ",(0,s.jsx)(i.code,{children:"v3-sdk"})," exports a handy utility function for that, ",(0,s.jsx)(i.code,{children:"tickToPrice"}),".\nWe store the Price as a string as we won't make any further calculations in this example. We will instead use it to display prices in the tooltip of our chart.\nNotice how the ",(0,s.jsx)(i.code,{children:"price0"})," is the Price of tokenA in terms of tokenB and the ",(0,s.jsx)(i.code,{children:"price1"})," is the Price of tokenB in terms of tokenA ",(0,s.jsx)(i.strong,{children:"at the specified Tick"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["If the ",(0,s.jsx)(i.strong,{children:"current Tick is initialized"}),", we also need to set the ",(0,s.jsx)(i.strong,{children:"liquidityNet"})," to correctly handle moving out of the position:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"const currentTickInitialized = tickIdxToTickDictionary[activeTickIdx];\nif (currentTickInitialized !== undefined) {\n  activeTickProcessed.liquidityNet = JSBI.BigInt(\n    currentTickInitialized.liquidityNet\n  );\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["We now start iterating outwards from the active Tick and compute the active liquidity for each Tick we want to display. The processed Tick is then saved in an Array of ",(0,s.jsx)(i.code,{children:"TickProcessed"}),".\nWe choose an arbitrary number of Ticks we want to display, for this example we calculate 100 Ticks in each direction."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"import { TickMath, tickToPrice } from '@swapx/v3-sdk'\n\nlet previousTickProcessed = {\n    ...activeTickProcessed\n}\n\nprocessedTicks: TickProcessed[] = []\n\nfor (let i = 0; i < 100; i++) {\n    const currentTickIdx = previousTickProcessed.tickIdx + tickSpacing\n\n    if (currentTickIdx > TickMath.MAX_TICK) {\n        break\n    }\n\n    const currentTickProcessed = {\n        liquidityActive: previousTickProcessed.liquidityActive,\n        tickIdx: currentTickIdx,\n        liquidityNet: JSBI.BigInt(0),\n        price0: tickToPrice(token0, token1, currentTickIdx),\n        price1: tickToPrice(token1, token0, currentTickIdx),\n        isActive: false\n    }\n\n    ...\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["We calculate one Tick at a time, and we need to make sure our Tick stays inside the possible price range by checking against ",(0,s.jsx)(i.code,{children:"TickMath.MAX_TICK"}),".\nAgain, we check if our current Tick is initialized and if so, recalculate the active liquidity:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"for (let i = 0; i < 100; i++) {\n\n    ...\n\n    const currentTickInitialized = tickIdxToTickDictionary[currentTickIdx]\n\n    if (currentTickInitialized !== undefined) {\n        currentTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)\n        currentTickProcessed.liquidityActive = JSBI.add(\n            previousTickProcessed.liquidityActive,\n            JSBI.BigInt(currentTickInitialized.liquidityNet)\n        )\n    }\n\n    processedTicks.push(currentTickProcessed)\n    previousTickProcessed = currentTickProcessed\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["After we are done calculating the next 100 Ticks after the current Tick, we iterate in the opposite direction for the previous Ticks. Iterating downwards, we need to subtract the net liquidity where we added it when iterating upwards.\nYou can find a full code example in the ",(0,s.jsx)(i.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/active-liquidity",children:"SwapX Example repository"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"We are finally able to combine the previous, active and subsequent Ticks:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"const allProcessedTicks = previousTicks\n  .concat(activeTickProcessed)\n  .concat(subsequentTicks);\n"})}),"\n",(0,s.jsx)(i.h2,{id:"drawing-the-chart",children:"Drawing the Chart"}),"\n",(0,s.jsxs)(i.p,{children:["We are done with our calculations and move on to displaying the data. ",(0,s.jsx)(i.strong,{children:"Recharts"})," is not able to handle JSBI, so we need to convert the Array we created to a format it can handle:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"const chartTicks: TicksChart[] = allProcessedTicks.map((tickProcessed) => {\n  return {\n    ...processedTick,\n    liquidityActiveChart: parseFloat(tickProcessed.liquidityActive.toString()),\n  };\n});\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The loss of precision will not be visually noticeable in the chart and we are still able to display the exact number in a Tooltip if we wish to.\nLiquidity is stored in a ",(0,s.jsx)(i.code,{children:"uint128"})," format onchain, so the maximum loss of precision will be far smaller than the number of decimals of almost any ERC20 Token."]}),"\n",(0,s.jsx)(i.p,{children:"Finally, we draw the Chart:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-jsx",children:'<ResponsiveContainer width="80%" height={400}>\n  <BarChart>\n    <XAxis />\n    <YAxis />\n    <Bar dataKey="liquidityActiveChart" fill="#2172E5">\n      {chartTicks.map((entry, index) => {\n        return (\n          <Cell\n            key={`cell-${index}`}\n            fill={entry.isActive ? "#F51E87" : "#2172E5"}\n          />\n        );\n      })}\n    </Bar>\n  </BarChart>\n</ResponsiveContainer>\n'})}),"\n",(0,s.jsxs)(i.p,{children:["In a real application, you will probably want to format the chart properly and display additional information for users.\nCheck out the full ",(0,s.jsx)(i.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/active-liquidity",children:"code example"})," to this guide and the official recharts ",(0,s.jsx)(i.a,{href:"https://recharts.org/",children:"documentation"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["You can also take a look at the ",(0,s.jsx)(i.a,{href:"https://github.com/SwapX/v3-info",children:"SwapX Info"})," repository to see a similar chart used in production."]}),"\n",(0,s.jsx)(i.h2,{id:"locked-liquidity",children:"Locked Liquidity"}),"\n",(0,s.jsx)(i.p,{children:"If you run the example, you will notice that the chart also displays a custom tooltip with additional information that we didn't touch on in this example.\nThe total locked liqudity in the tooltip represents the sum of positions in the currency locked at the selected Tick.\nIt is calculated as the maximum token output of a swap when crossing to the next Tick.\nThe V3 pool here is initialized with only the liquidity of the current Tick."}),"\n",(0,s.jsxs)(i.p,{children:["Depending on your use case, it may make sense to display this value. You can find the full code in the ",(0,s.jsx)(i.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/active-liquidity",children:"code example"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(i.p,{children:["Now that you are familiar with liquidity data, consider checking out our ",(0,s.jsx)(i.a,{href:"04-price-oracle",children:"next guide"})," on using SwapX as a Price Oracle."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>c,x:()=>a});var n=t(6540);const s={},r=n.createContext(s);function c(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);