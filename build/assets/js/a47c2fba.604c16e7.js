"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4849],{6422:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"sdk/v3/guides/advanced/pool-data","title":"pool-data","description":"Introduction","source":"@site/docs/sdk/v3/guides/advanced/02-pool-data.md","sourceDirName":"sdk/v3/guides/advanced","slug":"/sdk/v3/guides/advanced/pool-data","permalink":"/sdk/v3/guides/advanced/pool-data","draft":false,"unlisted":false,"editUrl":"https://github.com/hi-swapx/docs/docs/sdk/v3/guides/advanced/02-pool-data.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"\u6c60\u6570\u636e","sidebar_position":2},"sidebar":"sdkSidebar","previous":{"title":"\u4ecb\u7ecd","permalink":"/sdk/v3/guides/advanced/introduction"},"next":{"title":"\u4e3b\u52a8\u6d41\u52a8\u6027","permalink":"/sdk/v3/guides/advanced/active-liquidity"}}');var s=t(4848),o=t(8453);const c={sidebar_label:"\u6c60\u6570\u636e",sidebar_position:2},l=void 0,r={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Computing the Pool&#39;s deployment address",id:"computing-the-pools-deployment-address",level:2},{value:"Creating a Pool Contract instance and fetching metadata",id:"creating-a-pool-contract-instance-and-fetching-metadata",level:2},{value:"Fetching all Ticks",id:"fetching-all-ticks",level:2},{value:"Multicall",id:"multicall",level:2},{value:"Calculating all bitMap positions",id:"calculating-all-bitmap-positions",level:2},{value:"Fetching bitMaps from their position",id:"fetching-bitmaps-from-their-position",level:2},{value:"Calculating the memory positions of all Ticks",id:"calculating-the-memory-positions-of-all-ticks",level:2},{value:"Fetching all Ticks by their indices",id:"fetching-all-ticks-by-their-indices",level:2},{value:"Constructing the Pool",id:"constructing-the-pool",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["This guide will cover how to initialize a Pool with full tick data to allow offchain calculations. It is based on the ",(0,s.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/pool-data",children:"Fetching Pool data example"}),", found in the SwapX code examples ",(0,s.jsx)(n.a,{href:"https://github.com/SwapX/examples",children:"repository"}),". To run this example, check out the guide's ",(0,s.jsx)(n.a,{href:"https://github.com/SwapX/examples/blob/main/v3-sdk/pool-data/README.md",children:"README"})," and follow the setup instructions."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our ",(0,s.jsx)(n.a,{href:"01-background",children:"background"})," page!"]})}),"\n",(0,s.jsxs)(n.p,{children:["In this example we will use ",(0,s.jsx)(n.strong,{children:"ethers JS"})," and ",(0,s.jsx)(n.strong,{children:"ethers-multicall"})," to construct a ",(0,s.jsx)(n.code,{children:"Pool"})," object that we can use in the following guides."]}),"\n",(0,s.jsxs)(n.p,{children:["This guide will ",(0,s.jsx)(n.strong,{children:"cover"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Computing the Pool's address"}),"\n",(0,s.jsx)(n.li,{children:"Referencing the Pool contract and fetching metadata"}),"\n",(0,s.jsx)(n.li,{children:"Fetching the positions of all initialized Ticks with multicall"}),"\n",(0,s.jsx)(n.li,{children:"Fetching all ticks by their indices with a multicall"}),"\n",(0,s.jsx)(n.li,{children:"Constructing the Pool object"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["At the end of the guide, we will have created a ",(0,s.jsx)(n.code,{children:"Pool"})," Object that accurately represents the state of a V3 pool at the time we fetched it."]}),"\n",(0,s.jsx)(n.p,{children:"For this guide, the following SwapX packages are used:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/v3-sdk",children:(0,s.jsx)(n.code,{children:"@swapx/v3-sdk"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@swapx/sdk-core",children:(0,s.jsx)(n.code,{children:"@swapx/sdk-core"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We will also use the ",(0,s.jsx)(n.code,{children:"ethers-multicall"})," npm package:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/ethers-multicall",children:(0,s.jsx)(n.code,{children:"ethers-multicall"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The core code of this guide can be found in ",(0,s.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/multicall/src/libs/fetcher.ts",children:(0,s.jsx)(n.code,{children:"fetcher.ts"})})]}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The example accompanying this guide can be configured in the ",(0,s.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/multicall/src/config.ts",children:(0,s.jsx)(n.code,{children:"config.ts"})})," file.\nThe default configuration defines the rpc endpoint and the pool that is used for this guide:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const CurrentConfig: ExampleConfig = {\n  env: Environment.MAINNET,\n  rpc: {\n    local: 'http://localhost:8545',\n    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',\n  },\n  ...\n  pool: {\n    token0: USDC_TOKEN,\n    token1: WETH_TOKEN,\n    fee: FeeAmount.MEDIUM,\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["FeeAmount.MEDIUM means that the pool has a swap fee of ",(0,s.jsx)(n.strong,{children:"0.3%"}),".\nThe ",(0,s.jsx)(n.code,{children:"USDC_TOKEN"})," and ",(0,s.jsx)(n.code,{children:"WETH_TOKEN"})," are defined in the ",(0,s.jsx)(n.a,{href:"https://github.com/SwapX/examples/tree/main/v3-sdk/multicall/src/libs/constants.ts",children:(0,s.jsx)(n.code,{children:"constants.ts"})})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'export const WETH_TOKEN = new Token(\n  SupportedChainId.MAINNET,\n  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",\n  18,\n  "WETH",\n  "Wrapped Ether"\n);\n\nexport const USDC_TOKEN = new Token(\n  SupportedChainId.MAINNET,\n  "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",\n  6,\n  "USDC",\n  "USD//C"\n);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"computing-the-pools-deployment-address",children:"Computing the Pool's deployment address"}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we will construct the ",(0,s.jsx)(n.strong,{children:"USDC - WETH"})," Pool with ",(0,s.jsx)(n.strong,{children:"MEDIUM"})," fees. The SDK provides a method to compute the address:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { Pool } from "@swapx/v3-sdk";\nimport { CurrentConfig } from "../config.ts";\n\nconst poolAddress = Pool.getAddress(\n  CurrentConfig.pool.token0,\n  CurrentConfig.pool.token1,\n  CurrentConfig.pool.fee\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"SwapX V3 allows 4 different Fee tiers when deploying a pool, so multiple pools can exist for each pair of tokens."}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-pool-contract-instance-and-fetching-metadata",children:"Creating a Pool Contract instance and fetching metadata"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have the address of a ",(0,s.jsx)(n.strong,{children:"USDC - ETH"})," Pool, we can construct an instance of an ",(0,s.jsx)(n.strong,{children:"ethers"})," ",(0,s.jsx)(n.code,{children:"Contract"})," to interact with it.\nTo construct the Contract we need to provide the address of the contract, its ABI and a provider connected to an ",(0,s.jsx)(n.a,{href:"https://www.chainnodes.org/docs",children:"RPC endpoint"}),". We get access to the contract's ABI through the ",(0,s.jsx)(n.code,{children:"@swapx/v3-core"})," package, which holds the core smart contracts of the SwapX V3 protocol:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { ethers } from 'ethers\nimport ISwapXV3PoolABI from '@swapx/v3-core/artifacts/contracts/interfaces/ISwapXV3Pool.sol/ISwapXV3Pool.json'\n\nconst provider = getProvider()\nconst poolContract = new ethers.Contract(\n    poolAddress,\n    ISwapXV3PoolABI.abi,\n    provider\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getProvider()"})," function returns an ",(0,s.jsx)(n.code,{children:"ethers.providers.JsonRpcProvider"})," with either the local or mainnet rpc url that we defined, depending on the Environment that we set in ",(0,s.jsx)(n.code,{children:"config.ts"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Once we have set up our reference to the contract, we can proceed to access its methods. To construct our offchain representation of the Pool Contract, we need to fetch its liquidity, sqrtPrice, currently active tick and the full Tick data.\nWe get the ",(0,s.jsx)(n.strong,{children:"liquidity"}),", ",(0,s.jsx)(n.strong,{children:"sqrtPrice"})," and ",(0,s.jsx)(n.strong,{children:"tick"})," directly from the blockchain by calling ",(0,s.jsx)(n.code,{children:"liquidity()"}),"and ",(0,s.jsx)(n.code,{children:"slot0()"})," on the Pool contract:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [liquidity, slot0] = await Promise.all([\n  poolContract.liquidity(),\n  poolContract.slot0(),\n]);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"contracts/v3/reference/core/interfaces/pool/ISwapXV3PoolState.md#slot0",children:"slot0 function"})," represents the first (0th) storage slot of the pool and exposes multiple useful values in a single function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"  function slot0(\n  ) external view returns (\n    uint160 sqrtPriceX96,\n    int24 tick,\n    uint16 observationIndex,\n    uint16 observationCardinality,\n    uint16 observationCardinalityNext,\n    uint8 feeProtocol,\n    bool unlocked\n  )\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For our use case, we only need the ",(0,s.jsx)(n.code,{children:"sqrtPriceX96"})," and the currently active ",(0,s.jsx)(n.code,{children:"tick"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"fetching-all-ticks",children:"Fetching all Ticks"}),"\n",(0,s.jsxs)(n.p,{children:["V3 pools use ticks to ",(0,s.jsx)(n.a,{href:"concepts/protocol/concentrated-liquidity",children:"concentrate liquidity"})," in price ranges and allow for better pricing of trades.\nEven though most Pools only have a couple of ",(0,s.jsx)(n.strong,{children:"initialized ticks"}),", it is possible that a pools liquidity is defined by thousands of ",(0,s.jsx)(n.strong,{children:"initialized ticks"}),".\nIn that case, it can be very expensive or slow to get all of them with normal RPC calls."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are not familiar with the concept of ticks, check out the ",(0,s.jsx)(n.a,{href:"01-introduction",children:(0,s.jsx)(n.code,{children:"introduction"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To access tick data, we will use the ",(0,s.jsx)(n.code,{children:"ticks"})," function of the V3 Pool contract:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"  function ticks(\n    int24 tick\n  ) external view returns (\n    uint128 liquidityGross,\n    int128 liquidityNet,\n    uint256 feeGrowthOutside0X128,\n    uint256 feeGrowthOutside1X128,\n    int56 tickCumulativeOutside,\n    uint160 secondsPerLiquidityOutsideX128,\n    uint32 secondsOutside,\n    bool initialized\n  )\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"tick"})," parameter that we provide the function with is the ",(0,s.jsx)(n.strong,{children:"index"})," (memory position) of the Tick we are trying to fetch.\nTo get the indices of all initialized Ticks of the Pool, we can calculate them from the ",(0,s.jsx)(n.strong,{children:"tickBitmaps"}),".\nTo fetch a ",(0,s.jsx)(n.code,{children:"tickBitmap"})," function of the V3 Pool:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"  function tickBitmap(\n      int16 wordPosition\n  ) external view returns (uint256)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A pool stores lots of bitmaps, each of which contain the status of 256 Ticks.\nThe parameter ",(0,s.jsx)(n.code,{children:"int16 wordPosition"})," the function accepts is the position of the bitMap we want to fetch.\nWe can calculate all the position of bitMaps (or words as they are sometimes called) from the ",(0,s.jsx)(n.code,{children:"tickSpacing"})," of the Pool, which is in turn dependant on the Fee tier."]}),"\n",(0,s.jsx)(n.p,{children:"So to summarise we need 4 steps to fetch all initialized ticks:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Calculate all bitMap positions from the tickSpacing of the Pool."}),"\n",(0,s.jsx)(n.li,{children:"Fetch all bitMaps using their positions."}),"\n",(0,s.jsx)(n.li,{children:"Calculate the memory positions of all Ticks from the bitMaps."}),"\n",(0,s.jsx)(n.li,{children:"Fetch all Ticks by their memory position."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We will use multicalls for the fetch calls."}),"\n",(0,s.jsx)(n.h2,{id:"multicall",children:"Multicall"}),"\n",(0,s.jsxs)(n.p,{children:["Multicall contracts ",(0,s.jsx)(n.strong,{children:"aggregate results"})," from multiple contract calls and therefore allow sending multiple contract calls in ",(0,s.jsx)(n.strong,{children:"one RPC request"}),".\nThis can improve the ",(0,s.jsx)(n.strong,{children:"speed"})," of fetching large amounts of data significantly and ensures that the data fetched is all from the ",(0,s.jsx)(n.strong,{children:"same block"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We will use the Multicall2 contract by MakerDAO.\nWe use the ",(0,s.jsx)(n.code,{children:"ethers-muticall"})," npm package to easily interact with the Contract."]}),"\n",(0,s.jsx)(n.h2,{id:"calculating-all-bitmap-positions",children:"Calculating all bitMap positions"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned, SwapX V3 Pools store ",(0,s.jsx)(n.strong,{children:"bitmaps"}),", also called ",(0,s.jsx)(n.em,{children:"words"}),", that represent the state of ",(0,s.jsx)(n.strong,{children:"256 initializable ticks"})," at a time.\nThe value at a bit of a word is 1 if the tick at this index is initialized and 0 if it isn't.\nWe can calculate the positions of initialized ticks from the ",(0,s.jsx)(n.strong,{children:"words"})," of the Pool."]}),"\n",(0,s.jsxs)(n.p,{children:["All ticks of SwapX V3 pools are between the indices ",(0,s.jsx)(n.code,{children:"-887272"})," and ",(0,s.jsx)(n.code,{children:"887272"}),".\nWe can calculate the minimum and maximum word from these indices and the Pool's tickSpacing:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function tickToWord(tick: number): number {\n  let compressed = Math.floor(tick / tickSpacing);\n  if (tick < 0 && tick % tickSpacing !== 0) {\n    compressed -= 1;\n  }\n  return tick >> 8;\n}\n\nconst minWord = tickToWord(-887272);\nconst maxWord = tickToWord(887272);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Ticks can only be initialized at indices that are ",(0,s.jsx)(n.strong,{children:"divisible by the tickSpacing"}),".\nOne word contains 256 ticks, so we can compress the ticks by right shifting 8 bit."]}),"\n",(0,s.jsx)(n.h2,{id:"fetching-bitmaps-from-their-position",children:"Fetching bitMaps from their position"}),"\n",(0,s.jsxs)(n.p,{children:["Knowing the positions of words in the Pool contract, we can now fetch them from the Pool using multicall and the ",(0,s.jsx)(n.code,{children:"tickBitmap"})," read call."]}),"\n",(0,s.jsx)(n.p,{children:"First we initialize our multicall providers and Pool Contract:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { ethers } from "ethers";\nimport { Contract, Provider } from "ethers-multicall";\n\nconst ethersProvider = new ethers.providers.JsonRpcProvider("...rpcUrl");\nconst multicallProvider = new Provider(ethersProvider);\nawait multicallProvider.init();\n\nconst poolContract = new Contract(poolAddress, ISwapXV3PoolABI.abi);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"multicallProvider"})," creates the multicall request and sends it via the ethers Provider."]}),"\n",(0,s.jsxs)(n.p,{children:["Next we loop through all possible word positions and add a ",(0,s.jsx)(n.code,{children:"tickBitmap"})," call for each:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"let calls: any[] = [];\nlet wordPosIndices: number[] = [];\nfor (let i = minWord; i <= maxWord; i++) {\n  wordPosIndices.push(i);\n  calls.push(poolContract.tickBitmap(i));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We also keep track of the word position indices to be able to loop through them in the same order we added the calls to the array."}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.code,{children:"multicallProvider.all()"})," function to send a multicall and map the results:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const results: bigint[] = (await multicallProvider.all(calls)).map(\n  (ethersResponse) => {\n    return BigInt(ethersResponse.toString());\n  }\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A great visualization of what the bitMaps look like can be found in the ",(0,s.jsx)(n.a,{href:"https://SwapXv3book.com/docs/milestone_2/tick-bitmap-index/",children:"SwapX V3 development book"}),":"]}),"\n",(0,s.jsx)("img",{src:"/img/tickBitmap_cut.png",alt:"TickBitmap"}),"\n",(0,s.jsx)(n.p,{children:"We encourage anyone trying to get a deeper understanding of the SwapX protocol to read the SwapX V3 Book."}),"\n",(0,s.jsx)(n.h2,{id:"calculating-the-memory-positions-of-all-ticks",children:"Calculating the memory positions of all Ticks"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we fetched all ",(0,s.jsx)(n.strong,{children:"bitMaps"}),", we check which ticks are initialized and calculate the ",(0,s.jsx)(n.strong,{children:"tick position"})," from the ",(0,s.jsx)(n.strong,{children:"word index"})," and the ",(0,s.jsx)(n.strong,{children:"tickSpacing"})," of the pool."]}),"\n",(0,s.jsxs)(n.p,{children:["We check if a tick is ",(0,s.jsx)(n.strong,{children:"initialized"})," inside the word by shifting a bit by the index we are looking at and performing a bitwise AND operation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const bit = 1n;\nconst initialized = (bitmap & (bit << BigInt(i))) !== 0n;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the tick is ",(0,s.jsx)(n.strong,{children:"initialized"}),", we revert the compression from tick to word we made earlier by multiplying the word index with 256, which is the same as left shifting by 8 bit, adding the position we are currently at, and multiplying with the tickSpacing:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const tickIndex = (ind * 256 + i) * tickSpacing;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The whole loop looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const tickIndices: number[] = [];\n\nfor (let j = 0; j < wordPosIndices.length; j++) {\n  const ind = wordPosIndices[j];\n  const bitmap = results[j];\n\n  if (bitmap !== 0n) {\n    for (let i = 0; i < 256; i++) {\n      const bit = 1n;\n      const initialized = (bitmap & (bit << BigInt(i))) !== 0n;\n      if (initialized) {\n        const tickIndex = (ind * 256 + i) * tickSpacing;\n        tickIndices.push(tickIndex);\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We now have an array containing the indices of all initialized Ticks."}),"\n",(0,s.jsx)(n.h2,{id:"fetching-all-ticks-by-their-indices",children:"Fetching all Ticks by their indices"}),"\n",(0,s.jsxs)(n.p,{children:["We use the multicallProvider again to execute an aggregated read call for all tick indices.\nWe create an array of call Promises again and use ",(0,s.jsx)(n.code,{children:".all()"})," to make our multicall:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const calls: any[] = [];\n\nfor (const index of tickIndices) {\n  calls.push(poolContract.ticks(index));\n}\n\nconst results = await multicallProvider.all(calls);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Again, the order of the results array is the same as the elements in ",(0,s.jsx)(n.strong,{children:"tickIndices"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We are able to combine the ",(0,s.jsx)(n.strong,{children:"tickIndices"})," and ",(0,s.jsx)(n.strong,{children:"results"})," array to create an array of ",(0,s.jsx)(n.code,{children:"Tick"})," objects:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const allTicks: Tick[] = [];\n\nfor (let i = 0; i < tickIndices.length; i++) {\n  const index = tickIndices[i];\n  const ethersResponse = results[i];\n  const tick = new Tick({\n    index,\n    liquidityGross: JSBI.BigInt(ethersResponse.liquidityGross.toString()),\n    liquidityNet: JSBI.BigInt(ethersResponse.liquidityNet.toString()),\n  });\n  allTicks.push(tick);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We need to parse the response from our RPC provider to JSBI values that the v3-sdk can work with."}),"\n",(0,s.jsx)(n.h2,{id:"constructing-the-pool",children:"Constructing the Pool"}),"\n",(0,s.jsxs)(n.p,{children:["We have everything to construct our ",(0,s.jsx)(n.code,{children:"Pool"})," now:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const usdcWethPool = new Pool(\n  USDC,\n  WETH,\n  feeAmount,\n  slot0.sqrtPriceX96,\n  liquidity,\n  slot0.tick,\n  allTicks\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"With this fully initialized Pool, we can make accurate offchain calculations."}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["Now that you are familiar with fetching Pool data, continue your journey with the ",(0,s.jsx)(n.a,{href:"03-active-liquidity",children:"next example"})," on visualizing the Liquidity density of a pool."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>l});var i=t(6540);const s={},o=i.createContext(s);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);